---
title: "R Notebook"
output: html_notebook
---

This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook. When you execute code within the notebook, the results appear beneath the code. 

Try executing this chunk by clicking the *Run* button within the chunk or by placing your cursor inside it and pressing *Ctrl+Shift+Enter*. 

---
title: "Q-Warg analysis"
author: "Léa Bogdziewiez, SLU - UPSC"
output: html_document

---

This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook. When you execute code within the notebook, the results appear beneath the code.

Load the libraries needed to run the script: (only needed once when opening the notebook).

```{r Libraries, warning=TRUE}
# Library needed to run the code: (need to be installed beforehand)
library(data.table)
library(rlist)
library(hrbrthemes)
library(viridis)
library(tidyverse)
library(shiny)
library(tcltk)
library(shiny)
library(plotly)
library(magick)

print("libraries ready")
```

Choose the folder containing the data to analyze: The data will be organized to be plotted.

```{r Data_organization, warning=FALSE}
# choose working directory where the subfolders containing data tables generated with ImageJ are:
log_file <- file.choose()
work_folder <- dirname(log_file)
setwd(work_folder)

# take all the csv files in the working directory, searching in the subfolders too
# make a list of all csv files and create a data frame containing morphometry and fluorescence intensities
all_files <- list.files(path = work_folder, recursive = TRUE, full.names = TRUE)
file_list <- all_files[grepl("\\.csv$", all_files) & !grepl("saved", all_files, ignore.case = FALSE)]
csv_list <- lapply(file_list, function(file) {
  data <- read.csv(file)
  data$filename <- basename(file)
  return(data)
})
merged_csv <- bind_rows(csv_list)
merged_csv[c('condition', 'staining', 'other')] <- str_split_fixed(merged_csv$filename, '-', 3)

# Subset the raw data to take only the columns of interest
# rename columns for coordinates
df <- subset(merged_csv, select = c("condition", "Label", "Area", "Perimeter", "Circularity", "staining", "Mean", "OBox.Center.X", "OBox.Center.Y"))
df$cooX <- df$OBox.Center.X
df$cooY <- df$OBox.Center.Y

# create a new column to state the staining corresponding to the fluorescence intensity value
df$meanCW <- ifelse(df$staining == "CW", df$Mean, NA)
df$meanViability <- ifelse(df$staining == "Viability", df$Mean, NA)

# convert pixel size into µm: to have diameter of each object.
df <- df %>%
  mutate(diameter = (Perimeter / pi))

# create a new column with the name of each cell based on condition and label: 
df$medium <- df$condition
df <- unite(df, col='cell', c('condition', 'Label'), sep='-')

# subset the data frame
dta <- subset(df, select = c("medium","cell", "diameter", "Circularity", "meanCW", "meanViability", "cooX", "cooY"))

# new data frame with each row corresponding to one cell:
# associate CW and Viability fluorescence intensities with the morphometry measurements
wdta <- dta %>%
  group_by(cell) %>%
  summarise_all(funs(ifelse(all(is.na(.)), NA, first(na.omit(.)))))

print(wdta)

```

Determine a Viability threshold based on FDA (or other viability staining):

```{r Viability_threshold, warning=FALSE}
## USER INTERACTION - VIABILITY THRESHOLD ## -----------------------------------------------------------------------------------------
threshold_via_value <- reactiveVal(300)
# Define the UI
ui <- fluidPage(
  
  titlePanel("Plot with Slider"),
  mainPanel(
    plotOutput("plot", height = "400px"),
    fluidRow(
      sliderInput("slider_range", "Slider range:", min = min(wdta$meanViability), max = max(wdta$meanViability), value = c(200, 600), width = "100%"),
      sliderInput("threshold", "Threshold:", min = min(wdta$meanViability), max = max(wdta$meanViability), value = 300, step = 1, width = "100%"),
      actionButton("set_threshold", "Set Viability threshold"),
      textOutput("via_threshold")
      
    )
  )
)

# Define the server
server <- function(input, output, session) {
  
  output$plot <- renderPlot({
    ggplot(wdta, aes(meanViability, fill = medium, colour = medium)) +
      geom_density(alpha = 0.1) +
      ggtitle("Viability threshold") +
      geom_vline(xintercept = input$threshold, color = "black") +
      geom_vline(xintercept = input$slider_range[1], color = "red", linetype = "dashed") +
      geom_vline(xintercept = input$slider_range[2], color = "red", linetype = "dashed") +
      scale_x_continuous(trans = "log10", breaks = scales::trans_breaks("log10", function(x) 10^x), labels = scales::trans_format("log10", scales::math_format(10^.x)))
    })
  
# Update the range of the "My Slider" based on the "Slider Range"
  observe({
      updateSliderInput(session, "threshold",
                        min = input$slider_range[1],
                        max = input$slider_range[2])
  })
  
# Update the threshold value based on the slider range
  observeEvent(input$set_threshold, {
    threshold_via_value(input$threshold)
  })
  
  output$via_threshold <- renderText({
    paste("Viability threshold value:", threshold_via_value())
  })
  
 # Expose the threshold value outside the app
  output$threshold_value_outside <- reactive({
    reactiveValuesToList(threshold_via_value)$threshold_via_value
  })
}

# Run the Shiny app
set_via_app <- shinyApp(ui = ui, server = server)
set_via_app

thr_val <- isolate(threshold_via_value())
print(thr_val)

Viability_threshold_plot <- wdta %>%
  ggplot(aes(x = medium, y = meanViability)) +
  geom_jitter(aes(color = diameter), size = 0.8, alpha = 0.7) +
  scale_color_gradientn(colors= c("#440154", "#3b528b", "#21918c","#5ec962", "#fde725")) +
  geom_violin(color = 'black', scale = "area", draw_quantiles = c(0.5), alpha=0.2) +
  theme_bw() +
  theme(axis.text.x = element_text(angle=90, vjust = 0.5, hjust = 0.5))+
  ggtitle(paste("Viability threshold:", thr_val)) +
  xlab("Condition")+
  scale_y_log10()+
  geom_hline(yintercept = thr_val, color = "black", linewidth = 1)

print(Viability_threshold_plot)

Viability_threshold_curves <- ggplot(wdta, aes(meanViability, fill = medium, colour = medium)) +
  geom_density(alpha = 0.1) +
  ggtitle(paste("Viability threshold:", thr_val)) +
  geom_vline(xintercept = thr_val, color = "black", linewidth = 1)+
  scale_x_log10()

print(Viability_threshold_curves)

```

Plot data:

```{r Plots, warning=FALSE}
# filter out non Viability positive cells and non circular elements (that would not be healthy protoplasts/cells) 
########### Depending on the staining, the Viability mean might need to be adjusted. #####################################################
wdta$cellalive <- "no"
wdta$cellalive[wdta$Circularity >= 0.8 & wdta$meanViability >= thr_val] <- "yes"

# Working data frame with only living cells: 
livedta <- wdta %>%
  filter(cellalive != "no") 

# to add the n of each condition on top of the violin plot
n_counts <- table(livedta$medium)

# Violin plot representing the cell wall staining intensity 
# the color gradient of the points represents the cell size
# The plot is both printed in Rstudio and saved as PDF
CW_intensity_plot <- livedta %>%
  ggplot(aes(x = medium, y = meanCW)) +
  geom_jitter(aes(color = diameter), size = 0.5, alpha = 0.5) +
  scale_color_gradientn(colors= c("yellow", "red", "purple", "blue")) +
  geom_violin(color = 'black', scale = "area", draw_quantiles = c(0.5), alpha=0.1) +
  theme_bw() +
  theme(axis.text.x = element_text(angle=90, vjust = 0.5, hjust = 0.5))+
  ggtitle("CW intensity") +
  xlab("Condition") +
  ylab("Cell wall staining")+
  geom_text(data = data.frame(medium = names(n_counts), Value = as.numeric(n_counts)),
            aes(x = medium, y = max(livedta$meanCW) + 0.2, label = as.character(Value)),
            color = "black", size = 4, vjust = -0.5) +
  scale_y_log10() 

print(CW_intensity_plot)

# Violin plot representing the cell size
# the color gradient of the points represents the cell wall staining intensity 
# The plot is both printed in Rstudio and saved as PDF
CellSize_plot <- livedta %>%
  ggplot(aes(x = medium, y = diameter)) +
  geom_jitter(aes(color = meanCW), size = 0.5, alpha = 0.5) +
  scale_color_gradientn(colors= c("#440154", "#3b528b", "#21918c","#5ec962", "#fde725")) +
  geom_violin(color = 'black', scale = "area", draw_quantiles = c(0.5), alpha=0.1) +
  theme_bw() +
  theme(axis.text.x = element_text(angle=90, vjust = 0.5, hjust = 0.5))+
  ggtitle("Cell size distribution") +
  xlab("Condition") +
  ylab("Cell diameter")

print(CellSize_plot)

# Proportion of living cells from the number of segmented objects
# The plot is both printed in Rstudio and saved as PDF
LivingCells_proportion_plot <- wdta %>%
  group_by(medium, cellalive) %>%
  summarise(count = n()) %>%
  mutate(percentage = count / sum(count) * 100) %>%
  ggplot(aes(x = medium, y = count, fill = cellalive)) +
  geom_bar(stat = "identity") +
  scale_fill_manual("cellalive", values = c("no" = "black", "yes" = "orange")) +
  geom_text(aes(label = paste0(round(percentage), "%")), 
            position = position_stack(vjust = 0.5), size = 2, color="white") +
  ggtitle("Living cells %") +
  theme_bw() +
  theme(axis.text.x = element_text(angle=90, vjust = 0.5, hjust = 0.5))
  

print(LivingCells_proportion_plot)

```

Save data:

```{r Save_files, warning=FALSE}
save_place <- file.choose()
save_folder <- dirname(save_place)
setwd(save_folder)

# Save all data: all segmented objects (no filtering based on the viability)
full_name <- paste0("fulldata-saved_VT-", thr_val, "_", format(Sys.time(), "%Y%m%d_%H%M%S"), ".csv")
# Combine the working directory and file name to get the full file path
full_path <- file.path(save_folder, full_name)
# Save the CSV file
write.csv(wdta, file = full_path, row.names = FALSE, quote = FALSE)

# Save usable data frame as csv file
# Define the file name
livedta_name <- paste0("livedta-saved_VT-", thr_val, "_", format(Sys.time(), "%Y-%m-%d_%H%M%S"), ".csv")
# Combine the working directory and file name to get the full file path
livedta_path <- file.path(save_folder, livedta_name)
# Save the CSV file
write.csv(livedta, file = livedta_path, row.names = FALSE, quote = FALSE)

# save plots
plot_list <- list(CW_intensity_plot, CellSize_plot, LivingCells_proportion_plot, Viability_threshold_plot, Viability_threshold_curves)
plot_filename <- paste0("plots_VT-", thr_val, "_", format(Sys.time(), "%Y%m%d_%H%M%S"), ".pdf")
pdf(file.path(save_folder, plot_filename), width = 12, height = 6)

for (plot in plot_list) {
  print(plot)
}

# Close the PDF file
dev.off()


```

Create interactive folder and reorganize files to be used in the application:

```{r Interactive_folder, warning=FALSE}

# code to move the jpg and livedta-saved into a new folder to be used in the interactive plot app.

interactive_files <- file.choose()
interactive_folder <- dirname(interactive_files)

# Set your working directory
setwd(interactive_files)

# List all jpg files recursively
jpg_files <- list.files(pattern = "\\.jpg$", recursive = TRUE, full.names = TRUE)

# Create the new folder "interactive" if it doesn't exist
dir.create("interactive", showWarnings = FALSE)

# Move jpg files to the "interactive" folder
file.rename(jpg_files, file.path("interactive", basename(jpg_files)))

# Get the csv files called livedta-save
donnees_to_use <- list.files(pattern = "^livedta-save.*\\.csv$")

# Get the file information for each file
file_info <- file.info(donnees_to_use)

# Get the index of the file with the latest modification time: copy only the most recent file
latest_file_index <- which.max(file_info$mtime)

# Copy the latest file to the "interactive" directory
file.copy(donnees_to_use[latest_file_index], "interactive")

print("Data ready to be used in Shiny App")

```

Q-WARG shiny app to check data and segmentation:

```{r QWARG_app, warning=FALSE}
# Load your data
QWARG_place <- file.choose()
QWARG_folder <- dirname(QWARG_place)
setwd(QWARG_folder)

# List all the .rda files in the directory
livedta_files <- list.files(pattern = "^livedta-save.*\\.csv$")

# Load each .rda file
donnees <- read.csv(livedta_files)

pic <- list.files(pattern = "\\.jpg$")

Brightfield <- pic[grep("BF", pic)]
Viability <- pic[grep("Viability", pic)]
CellWall <- pic[grep("CW", pic)]

# Convert the image dimensions into pixels:
donnees$cooX_px <- donnees$cooX/0.6490139 
donnees$cooY_px <- donnees$cooY/0.6490139

ui <- fluidPage(
  theme = bslib::bs_theme(bootswatch = "darkly"),
  titlePanel("Q-Warg (Quantitative Wall Regeneration): check your data"),
  sidebarLayout(
    sidebarPanel(
      selectInput("select_column_value", "Select a condition:", choices = unique(donnees$medium))
    ),
    mainPanel(
      plotlyOutput("plot"),
      verbatimTextOutput("clicked_info"),
      verbatimTextOutput("pic"),
      h3("Images:"),
      fluidRow(
        column(width = 4,
               h4("Brightfield:"),
               imageOutput("zoomed_bf")),
        column(width = 4,
               h4("Viability:"),
               imageOutput("zoomed_via")),
        column(width = 4,
               h4("Cell wall:"),
               imageOutput("zoomed_cw"))
      )
    )
  )
)

# Define server logic
server <- function(input, output) {
  clicked_coords <- reactiveValues(cgX = NULL, cgY = NULL)
  real_coords <- reactiveValues(cX = NULL, cY= NULL)
  
  # Create an interactive dot plot with plotly
  output$plot <- renderPlotly({
    # Filter data based on selected x-axis
    condition <- donnees[donnees$medium == input$select_column_value, ]
    
    # Print out filtered data for debugging
    print(head(condition))
    
    # Plot
    p <- ggplot(condition, aes(x = medium, y = meanCW)) +
      geom_point(aes(color = meanViability), size = 1.5, alpha = 0.8, position = position_jitter(width = 0.4, height = 0)) +
      scale_color_gradientn(colors= c("yellow", "red", "purple", "blue")) 
      theme_bw() +
      ggtitle("CW intensity") +
      xlab("medium") +
      ylab("Cell wall staining")
    
    p <- ggplotly(p)
    
    p <- htmlwidgets::onRender(p, '
    function(el, x) {
      el.on("plotly_click", function(data) {
        Shiny.setInputValue("clicked_point", data.points[0].x + "," + data.points[0].y);
      });
    }
  ')
  })
  
  
  # Display clicked point info
  observeEvent(input$clicked_point, {
    req(input$clicked_point)
    coords <- strsplit(input$clicked_point, ",")[[1]]
    clicked_coords$cgX <- as.numeric(coords[1])
    clicked_coords$cgY <- as.numeric(coords[2])
  })
  
  # Function to calculate picture coordinates
  coordinates <- function(cgY, donnees) {
    cX <- donnees$cooX_px[donnees$meanCW == cgY]
    cY <- donnees$cooY_px[donnees$meanCW == cgY]
    return(c(cX, cY))
  }
  
  # Display clicked point info
  output$clicked_info <- renderPrint({
    req(clicked_coords$cgX, clicked_coords$cgY)
    paste("Clicked Point Coordinates: (X =", clicked_coords$cgX, ", Y =", clicked_coords$cgY, ")")
  })
  
  # Call the coordinates function to get picture coordinates
  output$pic <- renderPrint({ 
    coords <- coordinates(clicked_coords$cgY, donnees)
    paste("Picture coordinates: (X =", coords[1], ", Y =", coords[2], ")")
  })
  
  # Render the zoomed image
  output$zoomed_bf <- renderImage({
    req(input$select_column_value)
    image_condition <- input$select_column_value
    image_name <- paste0(image_condition, "-BF.jpg")
    # Construct the path to the selected image
    image_path <- file.path(QWARG_folder, image_name)
    # Read the image using magick package
    image <- image_read(image_path)
    # for pic coordinates
    coords <- coordinates(clicked_coords$cgY, donnees)
    # Define zoom region (adjust the zoom_factor and zoom_size as needed)
    zoom_factor <- 1  # You can adjust this value
    zoom_size <- 100 / zoom_factor
    x_start <- max(1, coords[1] - zoom_size / 2)
    y_start <- max(1, coords[2] - zoom_size / 2)
    x_end <- min(image_info(image)$width, coords[1] + zoom_size / 2)
    y_end <- min(image_info(image)$height, coords[2] + zoom_size / 2)
    # Crop the image to the zoom region
    zoomed_image <- image_crop(image, geometry_area(width = x_end - x_start, height = y_end - y_start, x_off = x_start, y_off = y_start))
    # Save the zoomed image to a temporary file
    temp_file <- tempfile(fileext = ".png")
    image_write(zoomed_image, temp_file)
    list(src = temp_file, contentType = 'image/png')
  }, deleteFile = TRUE)
  
  output$zoomed_via <- renderImage({
    req(input$select_column_value)
    image_condition <- input$select_column_value
    image_name <- paste0(image_condition, "-Viability.jpg")
    # Construct the path to the selected image
    image_path <- file.path(QWARG_folder, image_name)
    # Read the image using magick package
    image <- image_read(image_path)
    # for pic coordinates
    coords <- coordinates(clicked_coords$cgY, donnees)
    # Define zoom region (adjust the zoom_factor and zoom_size as needed)
    zoom_factor <- 1  # You can adjust this value
    zoom_size <- 100 / zoom_factor
    x_start <- max(1, coords[1] - zoom_size / 2)
    y_start <- max(1, coords[2] - zoom_size / 2)
    x_end <- min(image_info(image)$width, coords[1] + zoom_size / 2)
    y_end <- min(image_info(image)$height, coords[2] + zoom_size / 2)
    # Crop the image to the zoom region
    zoomed_image <- image_crop(image, geometry_area(width = x_end - x_start, height = y_end - y_start, x_off = x_start, y_off = y_start))
    # Save the zoomed image to a temporary file
    temp_file <- tempfile(fileext = ".png")
    image_write(zoomed_image, temp_file)
    list(src = temp_file, contentType = 'image/png')
  }, deleteFile = TRUE)
  
  output$zoomed_cw <- renderImage({
    req(input$select_column_value)
    image_condition <- input$select_column_value
    image_name <- paste0(image_condition, "-CW.jpg")
    # Construct the path to the selected image
    image_path <- file.path(QWARG_folder, image_name)
    # Read the image using magick package
    image <- image_read(image_path)
    # for pic coordinates
    coords <- coordinates(clicked_coords$cgY, donnees)
    # Define zoom region (adjust the zoom_factor and zoom_size as needed)
    zoom_factor <- 1  # You can adjust this value
    zoom_size <- 100 / zoom_factor
    x_start <- max(1, coords[1] - zoom_size / 2)
    y_start <- max(1, coords[2] - zoom_size / 2)
    x_end <- min(image_info(image)$width, coords[1] + zoom_size / 2)
    y_end <- min(image_info(image)$height, coords[2] + zoom_size / 2)
    # Crop the image to the zoom region
    zoomed_image <- image_crop(image, geometry_area(width = x_end - x_start, height = y_end - y_start, x_off = x_start, y_off = y_start))
    # Save the zoomed image to a temporary file
    temp_file <- tempfile(fileext = ".png")
    image_write(zoomed_image, temp_file)
    list(src = temp_file, contentType = 'image/png')
  }, deleteFile = TRUE)
}

# Run the application
shinyApp(ui = ui, server = server)


```

When you save the notebook, an HTML file containing the code and output will be saved alongside it (click the *Preview* button or press *Ctrl+Shift+K* to preview the HTML file). The preview shows you a rendered HTML copy of the contents of the editor. Consequently, unlike *Knit*, *Preview* does not run any R code chunks. Instead, the output of the chunk when it was last run in the editor is displayed.
